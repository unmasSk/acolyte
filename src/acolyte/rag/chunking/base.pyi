from abc import ABC, abstractmethod
from typing import List, Dict, Optional, Tuple, Set, Any

from acolyte.models.chunk import Chunk, ChunkType
from acolyte.core.secure_config import Settings
from .mixins import ComplexityMixin, TodoExtractionMixin

class BaseChunker(ABC, ComplexityMixin, TodoExtractionMixin):
    config: Settings
    chunk_size: int
    overlap: float
    parser: Any
    language: Any
    chunk_node_types: Dict[str, ChunkType]
    token_counter: Any
    _tree_sitter_supported: bool

    def __init__(self) -> None: ...
    @abstractmethod
    def _get_language_name(self) -> str: ...
    @abstractmethod
    def _get_tree_sitter_language(self) -> Any: ...
    @abstractmethod
    def _get_import_node_types(self) -> List[str]: ...
    def _get_chunk_size(self) -> int: ...
    def _get_chunk_node_types(self) -> Dict[str, ChunkType]: ...
    async def chunk(self, content: str, file_path: str) -> List[Chunk]: ...
    def _extract_imports(
        self,
        root_node: Any,
        lines: List[str],
        file_path: str,
        processed_ranges: Dict[str, Set[Tuple[int, int]]],
    ) -> List[Chunk]: ...
    def _create_chunk_from_node(
        self,
        node: Any,
        lines: List[str],
        file_path: str,
        chunk_type: ChunkType,
        processed_ranges: Dict[str, Set[Tuple[int, int]]],
    ) -> Optional[Chunk]: ...
    def _extract_node_name(self, node: Any) -> Optional[str]: ...
    def _extract_dependencies_from_imports(self, import_nodes: List[Any]) -> List[str]: ...
    def _extract_remaining_code(
        self,
        root_node: Any,
        lines: List[str],
        file_path: str,
        processed_ranges: Dict[str, Set[Tuple[int, int]]],
    ) -> List[Chunk]: ...
    def _create_chunk(
        self,
        content: str,
        chunk_type: ChunkType,
        file_path: str,
        start_line: int,
        end_line: int,
        name: Optional[str] = ...,
    ) -> Chunk: ...
    def _chunk_by_lines(
        self, content: str, file_path: str, chunk_type: ChunkType = ...
    ) -> List[Chunk]: ...
    def _add_smart_overlap(
        self, chunks: List[Chunk], preserve_imports: bool = ...
    ) -> List[Chunk]: ...
    def _generate_overlap_content(
        self, previous: Chunk, current: Chunk, include_imports: bool
    ) -> str: ...
    def _validate_chunks(self, chunks: List[Chunk]) -> List[Chunk]: ...
    def _split_large_chunk(self, chunk: Chunk, max_tokens: int) -> List[Chunk]: ...

class LanguageChunker(BaseChunker):
    @abstractmethod
    def _get_chunk_node_types(self) -> Dict[str, ChunkType]: ...
    @abstractmethod
    def _extract_dependencies_from_imports(self, import_nodes: List[Any]) -> List[str]: ...
    @abstractmethod
    def _is_comment_node(self, node: Any) -> bool: ...
    def _should_include_node(self, node: Any) -> bool: ...
    def _post_process_chunk(self, chunk: Chunk) -> Optional[Chunk]: ...
    def _enhance_chunk_metadata(self, chunk: Chunk, node: Any) -> None: ...
