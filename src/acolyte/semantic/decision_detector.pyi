from typing import Optional, List, Dict
import re
from acolyte.models.technical_decision import DecisionType
from acolyte.models.semantic_types import DetectedDecision
from acolyte.core.tracing import MetricsCollector

class DecisionDetector:
    language: str
    auto_detect: bool
    explicit_marker: str
    patterns: Dict[str, List[str]]
    metrics: MetricsCollector

    def __init__(self) -> None: ...
    def detect_technical_decision(
        self, message: str, context: Optional[str] = ...
    ) -> Optional[DetectedDecision]: ...
    def _extract_explicit_decision(self, message: str) -> DetectedDecision: ...
    def _detect_automatic_decision(
        self, message: str, lang: str, context: Optional[str] = ...
    ) -> Optional[DetectedDecision]: ...
    def _extract_decision_from_match(
        self, match: re.Match[str], pattern: str, message: str, context: str
    ) -> DetectedDecision: ...
    def _create_decision_from_pattern(
        self, match: re.Match[str], decision_type: str, message: str, context: str
    ) -> DetectedDecision: ...
    def _extract_rationale(self, message: str, start_pos: int) -> Optional[str]: ...
    def _get_default_patterns(self) -> Dict[str, List[str]]: ...
    def _estimate_impact(self, decision_type: DecisionType, message: str) -> int: ...
